name: Deploy image-post to Amazon ECS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: image-post
  ECS_CLUSTER: image-post-cluster
  ECS_TASK_DEFINITION: image-post-task
  CONTAINER_NAME: image-post

permissions:
  contents: read

jobs:
  build-and-push-image:
    name: Build and Push Image
    runs-on: ubuntu-latest # Job 실행을 위한 Runner (ubuntu, macOS, windows... 중 우분투 선택)
    outputs:
      image_tag: ${{ steps.set-tag.outputs.tag }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'correto'
        cache: gradle

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew # 가상 머신에서 gradlew 파일에 실행 권한 부여

    - name: Build with Gradle
      run: ./gradlew build # 가상머신에서 gradle을 사용해 JAR 파일 빌드

    - name: Configure AWS credentials for deployment
      # Github Actions Runner가 AWS API를 호출할 수 있는 자격 증명 설정
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      # 액션 내부에서 AWS에 토큰을 요청해 도커가 ECR에 로그인
      # 로그인 후 내부에서 Registry URL을 생성해 $GITHUB_OUTPUT에 작성함
      # 이후 step에서 steps.login-ecr.outputs.registry로 접근 가능

    - name: Set Image Tag
      id: set-tag
      run: |
        TAG=$(date +'%Y%m%d%H%M%S')-${GITHUB_SHA::8}
        echo "tag=${TAG}" >> $GITHUB_OUTPUT
      # outputs에 tag 값 설정

    - name: Build, tag, and push Docker image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.set-tag.outputs.tag }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  deploy-to-ecs: # 두 번째 Job
    name: Deploy to ECS
    runs-on: ubuntu-latest # 이 job은 새로운 환경에서 실행되므로, 새로운 서버에서 실행됨
    needs: build-and-push-image # 'build-and-push-image' job 완료 후 실행

    steps:
      - name: Configure AWS credentials for deployment
        uses: aws-actions/configure-aws-credentials@v2
        # ECS 배포를 위한 AWS 자격 증명 설정
        # 새로운 서버에서 실행되므로 AWS 자격 증명을 다시 설정해야 함
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download task definition
        run: |
          aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --query taskDefinition > task-definition.json
        # 기존 존재하던 AWS ECS task definition을 task-definition.json 파일로 저장
        # 이 파일은 현재 Job이 실행 중인 GitHub Actions Runner(임시 VM)의 작업 디렉토리에 생성됨

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: render-task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        # 기존 ECS task definition JSON을 가져와, (task-definition.json 읽음)
        # 컨테이너를 찾아 이미지 값을 새 이미지 태그로 교체한 뒤,
        # 새로운 task definition JSON 파일을 만들어 output으로 제공
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }} # image 필드를 바꿀 컨테이너 이름과, 새 image 전달
          image: ${{ needs.build-and-push-image.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${ needs.build-and-push-image.outputs.image_tag }}
        # 이후 업데이트 된 task definition을 새로운 파일로 저장 (파일 이름은 자동 생성)
        # 파일은 output으로 내보내짐 (outputs: task-definition: rendered-task-definition.json (예시))

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        # task definition JSON을 ECS에 새 버전으로 등록 (ECS는 revision 번호를 붙임 (v1->v2->...)
        # 새 컨테이너 이미지 반영해 지정된 ECS 서비스 롤링 업데이트 (기존 컨테이너 -> 새 컨테이너 교체)
        # output으로 새 task definition ARN 제공 (여기서는 사용 X)
        with:
          task-definition: ${{ steps.render-task-def.outputs.task-definition }}
          # 이전 step의 output으로 제공된, 업데이트된 task-definition 파일
          service: ${{ env.ECS_SERVICE }} # 배포할 ECS 서비스 이름
          cluster: ${{ env.ECS_CLUSTER }} # 클러스터 이름
          wait-for-service-stability: true # 배포 완료 및 안정화 될 때까지 대기
          # ECS가 모든 컨테이너를 새 task definition으로 교체하고,
          # RUNNING 상태가 안정될 때까지 기다리며 다음 step으로 넘어가지 않음.
          # (안정 상태 - 정의된 task 수와 RUNNING 상태 task 수 동일 / 헬스 체크 통과 / 롤링 배포 완료)

      - name: Verify deployment stability # 추가 검증 단계 (선택 사항)
        run: |
          echo "Checking service stability. . ."
          aws ecs wait service-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }}
        # 위 step의 wait-for-service-stability와 동일한 검증
          echo "Service is stable."